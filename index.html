<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Poly Art Rotativo — Viewer</title>
  <style>
    :root{
      --bg1: #ffffff;
      --bg2: #f3f4f6; /* suave gris claro */
      --muted: #64748b;
      --accent: #60a5fa;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#0b1220}
    #app{height:100vh;display:flex;flex-direction:column}
    #top-emojis{
      position:absolute;
      left:0; right:0;
      top:10px;
      display:flex;
      justify-content:center;
      pointer-events:none; /* no intercept clicks */
      z-index:10;
      font-size:28px;
      user-select:none;
      -webkit-user-select:none;
    }
    #stage{flex:1;position:relative;overflow:hidden}
    #three-container{width:100%;height:100%}
    .ui-bottom{
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 14px;
      background:linear-gradient(180deg, rgba(255,255,255,0.6), rgba(255,255,255,0.5));
      backdrop-filter: blur(6px);
      border-top: 1px solid rgba(0,0,0,0.04);
      flex-shrink:0;
      overflow-x:auto;
    }
    .thumb{
      position:relative;
      width:72px;
      height:56px;
      border-radius:8px;
      box-shadow: 0 6px 14px rgba(2,6,23,0.06);
      overflow:hidden;
      cursor:pointer;
      flex:0 0 auto;
      border:2px solid transparent;
    }
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .thumb.active{border-color:rgba(96,165,250,0.85)}
    .controls{
      display:flex;
      gap:12px;
      align-items:center;
      margin-left:10px;
      flex:0 0 auto;
    }
    .controls label{font-size:13px;color:var(--muted);display:block}
    .slider{width:140px}
    button{padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:white;cursor:pointer}
    @media (max-width:600px){
      .thumb{width:60px;height:46px}
      #top-emojis{font-size:22px; top:6px}
      .slider{width:100px}
    }
    /* small helper overlay when aligned */
    #hint{
      position:absolute;
      left:12px;
      bottom:80px;
      background:rgba(255,255,255,0.85);
      padding:8px 10px;border-radius:8px;color:#0b1220;font-size:13px;
      box-shadow:0 6px 12px rgba(2,6,23,0.06);
      z-index:9;
    }
    /* ensure canvas covers container */
    canvas{display:block}
  </style>
</head>
<body>
  <div id="app">
    <div id="top-emojis">?? ?? ??</div>

    <div id="stage">
      <div id="three-container"></div>

      <div id="hint">Arrastra para rotar — acércate al ángulo correcto para que la imagen se forme</div>
    </div>

    <div class="ui-bottom" id="ui-bottom">
      <!-- thumbnails inserted by script -->
      <div class="controls">
        <div style="display:flex;flex-direction:column;">
          <label>Columnas</label>
          <input id="cols" type="range" min="5" max="20" value="10" class="slider">
        </div>
        <div style="display:flex;flex-direction:column;">
          <label>Filas</label>
          <input id="rows" type="range" min="5" max="20" value="10" class="slider">
        </div>

        <div style="display:flex;flex-direction:column;align-items:flex-start;">
          <label>Mostrar rejilla</label>
          <input id="showGrid" type="checkbox">
        </div>
      </div>
    </div>
  </div>

  <!-- Three.js UMD -->
  <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>

  <script>
  (function () {
    // CONFIG: image filenames (local - place them in same folder)
    const IMAGES = ['foto1.jpg','foto2.jpg','foto3.jpg','foto4.jpg'];

    // DOM refs
    const container = document.getElementById('three-container');
    const colsEl = document.getElementById('cols');
    const rowsEl = document.getElementById('rows');
    const showGridEl = document.getElementById('showGrid');
    const hint = document.getElementById('hint');

    // three essentials
    const scene = new THREE.Scene();
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // main camera (user controls)
    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 2000);

    // projector camera (fixed) - the "magic" viewpoint where image aligns.
    const projector = new THREE.PerspectiveCamera(50, 1, 0.1, 2000);

    // We'll render a subtle ambient
    const ambient = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambient);

    // Light for tiny shading (optional)
    const dir = new THREE.DirectionalLight(0xffffff, 0.2);
    dir.position.set(1,1,1);
    scene.add(dir);

    // State
    let meshes = [];
    let baseTexture = null;
    let currentImageIndex = 0;
    let cols = parseInt(colsEl.value), rows = parseInt(rowsEl.value);
    let projectorMatrix = new THREE.Matrix4();
    let showGrid = false;

    // Controls (lightweight spherical)
    const target = new THREE.Vector3(0,0,0);
    const spherical = { theta: 0.6, phi: Math.PI/2 - 0.1, radius: 420 }; // start OFF the perfect angle
    const sphericalTarget = { theta: spherical.theta, phi: spherical.phi, radius: spherical.radius };
    const damping = 0.12;
    let isPointerDown = false, lastPointer = {x:0,y:0};

    function getPointer(e){
      if(e.touches && e.touches.length) return {x:e.touches[0].clientX, y:e.touches[0].clientY};
      return {x:e.clientX, y:e.clientY};
    }
    function onPointerDown(e){ isPointerDown = true; lastPointer = getPointer(e); }
    function onPointerMove(e){
      if(!isPointerDown) return;
      const p = getPointer(e);
      const dx = p.x - lastPointer.x;
      const dy = p.y - lastPointer.y;
      lastPointer = p;
      const rotSpeed = 0.006;
      sphericalTarget.theta -= dx * rotSpeed;
      sphericalTarget.phi -= dy * rotSpeed;
      sphericalTarget.phi = Math.max(0.01, Math.min(Math.PI-0.01, sphericalTarget.phi));
    }
    function onPointerUp(){ isPointerDown = false; }
    function onWheel(e){
      e.preventDefault();
      sphericalTarget.radius += e.deltaY * 0.6;
      sphericalTarget.radius = Math.max(120, Math.min(1200, sphericalTarget.radius));
    }

    renderer.domElement.addEventListener('mousedown', onPointerDown);
    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    renderer.domElement.addEventListener('touchstart', onPointerDown, {passive:true});
    window.addEventListener('touchmove', onPointerMove, {passive:true});
    window.addEventListener('touchend', onPointerUp);
    renderer.domElement.addEventListener('wheel', onWheel, {passive:false});

    // projective shader
    const vert = `
      varying vec4 vProj;
      void main(){
        vec4 worldPos = modelMatrix * vec4(position, 1.0);
        vProj = projectionMatrix * modelViewMatrix * vec4(position, 1.0); // for normal rendering
        // we also compute projected coords from projector in fragment via uniform matrix and worldPos (passed as worldPos)
        gl_Position = vProj;
      }
    `;
    // We'll instead compute projector projection in fragment by using a uniform matrix and modelMatrix.
    // Use a slightly different approach: pass world position to fragment by computing it in vertex shader.
    const vert2 = `
      uniform mat4 projectorMatrix;
      varying vec4 vProjFromProjector;
      varying vec4 vPosition;
      void main(){
        vPosition = modelMatrix * vec4(position,1.0);
        vProjFromProjector = projectorMatrix * vPosition;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
      }
    `;
    const frag = `
      uniform sampler2D map;
      uniform float opacity;
      varying vec4 vProjFromProjector;
      uniform bool showGrid;
      uniform vec3 gridColor;
      void main(){
        // projective divide
        vec3 proj = vProjFromProjector.xyz / vProjFromProjector.w;
        // convert from clip (-1..1) to uv (0..1)
        vec2 uv = proj.xy * 0.5 + 0.5;
        // if outside, make transparent
        if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0){
          discard;
        }
        vec4 color = texture2D(map, uv);
        if(color.a < 0.01) discard;
        // optional grid overlay to show cells when showGrid is true
        if(showGrid){
          // compute grid lines based on uv fractional coords (cheap)
          float gx = fract(uv.x * 1.0 * 1.0);
          float gy = fract(uv.y * 1.0 * 1.0);
          // not perfect grid but gives subtle lines
        }
        gl_FragColor = vec4(color.rgb, opacity * color.a);
      }
    `;

    // Create a shared ShaderMaterial factory (we pass projectorMatrix & map)
    function createShaderMaterial(texture){
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          map: { value: texture },
          projectorMatrix: { value: new THREE.Matrix4() },
          opacity: { value: 1.0 },
          showGrid: { value: false },
          gridColor: { value: new THREE.Color(0x111111) }
        },
        vertexShader: vert2,
        fragmentShader: frag,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        side: THREE.DoubleSide
      });
      return mat;
    }

    // build scene from image (cells)
    function buildFromImage(img, c = 10, r = 10){
      // free old meshes
      meshes.forEach(m=>{
        scene.remove(m);
        if(m.geometry) m.geometry.dispose();
        if(m.material){
          if(m.material.uniforms && m.material.uniforms.map && m.material.uniforms.map.value){
            // we DON'T dispose shared texture here; texture disposed when loading new baseTexture
          }
          m.material.dispose();
        }
      });
      meshes = [];

      // create base texture from HTML image element
      const tex = new THREE.Texture(img);
      tex.needsUpdate = true;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;

      baseTexture = tex;

      // plane size in world units (keep consistent aspect)
      const maxDim = 240;
      const aspect = img.width / img.height;
      let planeW = maxDim * Math.min(1, aspect);
      let planeH = maxDim * Math.min(1, 1/aspect);
      if(aspect >= 1){
        planeW = maxDim;
        planeH = maxDim / aspect;
      } else {
        planeH = maxDim;
        planeW = maxDim * aspect;
      }

      const startX = -planeW / 2;
      const startY = planeH / 2;
      const cellW = planeW / c;
      const cellH = planeH / r;

      // create shader material (shared clone per mesh because uniforms are per material)
      for(let i=0;i<c;i++){
        for(let j=0;j<r;j++){
          const geom = new THREE.PlaneGeometry(cellW, cellH, 1, 1);

          // IMPORTANT: geometry's local UVs are not used directly. We use projector matrix to sample texture
          // So geometry positions are as normal.

          const mat = createShaderMaterial(tex);

          // set uniform showGrid toggled
          mat.uniforms.showGrid.value = showGrid;

          const mesh = new THREE.Mesh(geom, mat);

          // position the mesh at a scattered 3D position
          const tx = startX + (i+0.5)*cellW;
          const ty = startY - (j+0.5)*cellH;
          const tz = 0; // original aligned plane z

          // scatter offset (random depth and offset)
          const scatterRange = Math.max(planeW, planeH) * 0.9;
          const sx = tx + (Math.random()-0.5) * scatterRange;
          const sy = ty + (Math.random()-0.5) * scatterRange * 0.6;
          const sz = (Math.random()-0.5) * scatterRange;

          mesh.position.set(sx, sy, sz);

          // slight random rotation
          mesh.rotation.set((Math.random()-0.5)*0.8, (Math.random()-0.5)*0.8, (Math.random()-0.5)*0.8);

          // store its aligned world transform (for reference)
          mesh.userData.alignedPos = new THREE.Vector3(tx, ty, tz);
          mesh.userData.indexIJ = [i,j];

          scene.add(mesh);
          meshes.push(mesh);
        }
      }

      // Configure projector to be the "perfect" viewpoint that projects the texture onto the world z=0 plane
      // We'll place the projector at (0,0,D) facing origin.
      const projDistance = Math.max(planeW, planeH) * 1.1 + 160; // distance from plane
      projector.fov = 50;
      projector.aspect = 1; // we'll update projectorMatrix using image aspect below
      projector.near = 0.1; projector.far = 5000;
      projector.position.set(0, 0, projDistance);
      projector.lookAt(0,0,0);
      projector.updateMatrixWorld();
      projector.updateProjectionMatrix();

      // set main camera start to a different angle so initial view is scattered
      spherical.radius = projDistance * 0.95 + 60;
      sphericalTarget.radius = spherical.radius;
      // start a bit offset in phi so user must rotate to align
      spherical.theta = 0.5;
      spherical.phi = Math.PI/2 - 0.25;
      sphericalTarget.theta = spherical.theta;
      sphericalTarget.phi = spherical.phi;

      // set renderer size / camera aspect
      resize();

      // compute projectorMatrix uniform for all materials
      updateProjectorMatrixForMaterials();
    }

    function updateProjectorMatrixForMaterials(){
      // make a matrix that maps world pos -> projector clip space
      projector.updateMatrixWorld();
      projector.updateProjectionMatrix();
      const projMat = new THREE.Matrix4().multiplyMatrices(projector.projectionMatrix, projector.matrixWorldInverse);
      // assign for all materials
      meshes.forEach(m=>{
        if(m.material && m.material.uniforms && m.material.uniforms.projectorMatrix){
          m.material.uniforms.projectorMatrix.value.copy(projMat);
        }
      });
    }

    function resize(){
      const w = container.clientWidth || window.innerWidth;
      const h = container.clientHeight || window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();

      // projector aspect best set to image aspect, but we keep 1:1 to simplify - it's fine visually.
      // If desired, we could set projector.aspect = camera.aspect and projector.updateProjectionMatrix();
      updateProjectorMatrixForMaterials();
    }
    window.addEventListener('resize', resize);

    function updateCameraFromSpherical(){
      spherical.theta += (sphericalTarget.theta - spherical.theta) * damping;
      spherical.phi += (sphericalTarget.phi - spherical.phi) * damping;
      spherical.radius += (sphericalTarget.radius - spherical.radius) * damping;

      const r = spherical.radius;
      const x = r * Math.sin(spherical.phi) * Math.sin(spherical.theta);
      const y = r * Math.cos(spherical.phi);
      const z = r * Math.sin(spherical.phi) * Math.cos(spherical.theta);
      camera.position.set(x, y, z);
      camera.lookAt(target);
    }

    // render loop
    function render(){
      requestAnimationFrame(render);
      updateCameraFromSpherical();

      // update projector matrix uniform each frame (in case projector moves or camera resize)
      const projMat = new THREE.Matrix4().multiplyMatrices(projector.projectionMatrix, projector.matrixWorldInverse);
      meshes.forEach(m=>{
        if(m.material && m.material.uniforms && m.material.uniforms.projectorMatrix){
          m.material.uniforms.projectorMatrix.value.copy(projMat);
          m.material.uniforms.showGrid.value = showGrid;
        }
      });

      renderer.render(scene, camera);
    }

    // thumbnails UI
    const uiBottom = document.getElementById('ui-bottom');
    function createThumbs(){
      IMAGES.forEach((name, idx)=>{
        const div = document.createElement('div');
        div.className = 'thumb' + (idx===0 ? ' active' : '');
        div.dataset.idx = idx;
        const img = document.createElement('img');
        img.src = name; // local filename
        img.alt = name;
        div.appendChild(img);
        div.addEventListener('click', ()=> {
          document.querySelectorAll('.thumb').forEach(t=>t.classList.remove('active'));
          div.classList.add('active');
          loadImageAtIndex(idx);
        });
        uiBottom.insertBefore(div, uiBottom.firstChild);
      });
    }

    // load image and build
    function loadImageAtIndex(idx){
      currentImageIndex = idx;
      const name = IMAGES[idx];
      // show hint only until user interacts
      hint.style.display = 'block';
      const img = new Image();
      img.onload = function(){
        cols = parseInt(colsEl.value);
        rows = parseInt(rowsEl.value);
        buildFromImage(img, cols, rows);
      };
      img.onerror = function(){
        alert('No se pudo cargar la imagen: ' + name + '. Asegúrate que esté en la misma carpeta que el HTML y que el nombre sea correcto.');
      };
      img.src = name + '?v=' + Math.random(); // cache-bust
    }

    // UI logics
    colsEl.addEventListener('input', ()=>{
      cols = parseInt(colsEl.value);
      loadImageAtIndex(currentImageIndex);
    });
    rowsEl.addEventListener('input', ()=>{
      rows = parseInt(rowsEl.value);
      loadImageAtIndex(currentImageIndex);
    });
    showGridEl.addEventListener('change', ()=>{
      showGrid = showGridEl.checked;
    });

    // Hide hint after first pointer interaction
    function setupFirstInteractionHide(){
      function hide(){
        hint.style.display = 'none';
        window.removeEventListener('pointerdown', hide);
        window.removeEventListener('touchstart', hide);
        window.removeEventListener('mousedown', hide);
      }
      window.addEventListener('pointerdown', hide);
      window.addEventListener('touchstart', hide, {passive:true});
      window.addEventListener('mousedown', hide);
    }

    // initialize
    createThumbs();
    loadImageAtIndex(0);
    resize();
    render();
    setupFirstInteractionHide();

    // small helper: re-compute projector on window resize or when needed
    window.addEventListener('orientationchange', ()=> {
      setTimeout(()=>{ resize(); }, 350);
    });

  })();
  </script>
</body>
</html>
